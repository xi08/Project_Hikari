C251 COMPILER V5.60.0,  indNavi                                                            14/03/22  14:46:08  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE indNavi
OBJECT MODULE PLACED IN .\Output\indNavi.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE User\indNavi.c XSMALL INTR2 WARNINGLEVEL(3) BROWSE INCDIR(.\Code;.\Lib
                    -\libraries;.\Lib\seekfree_libraries;.\Lib\seekfree_peripheral;.\User) DEFINE(USE_8701E) DEBUG PRINT(.\Output\indNavi.lst
                    -) OBJECT(.\Output\indNavi.obj) 

stmt  level    source

    1          /*  code=utf-8
    2              Project Hikari 前瞻电感
    3          */
    4          #include "indNavi.h"
    5          #include "string.h"
    6          //电感原始数据
    7          volatile uint16 indRawData[indNum], indRawDataMax[indNum], indRawDataMin[indNum];
    8          //电感滤波后数据
    9          volatile uint16 indFilteredData[indNum];
   10          //归一化上下限值
   11          volatile uint16 indMaxData[indNum], indMinData[indNum];
   12          
   13          //电感初始化
   14          void indInit(void)
   15          {
   16   1          // 初始化adc
   17   1          adc_init(IND_LL, ADC_SYSclk_DIV_2);
   18   1          adc_init(IND_MF, ADC_SYSclk_DIV_2);
   19   1          adc_init(IND_RR, ADC_SYSclk_DIV_2);
   20   1      #ifdef IND_EXT_MidSide
                   adc_init(IND_LM, ADC_SYSclk_DIV_2);
                   adc_init(IND_RM, ADC_SYSclk_DIV_2);
               #endif
   24   1      #ifdef IND_EXT_MidRear
                   adc_init(IND_MR, ADC_SYSclk_DIV_2);
               #endif
   27   1          // 设置归一化初始下限的值
   28   1          memset(indMinData, 0xff, indNum * sizeof(uint16));
   29   1      }
   30          //获取已滤波，已归一化的电感数据，以 LL-MF-RR-LM-RM-RR-MR 序列给出
   31          void getIndInfo(uint8 *indDataArray)
   32          {
   33   1          uint8 i, j;
   34   1          // 设置比较量的值
   35   1          memset(indRawDataMin, 0xff, indNum * sizeof(uint16));
   36   1          //滤波前获取数据
   37   1          for (i = 0; i < indAvgFilterNum; i++)
   38   1          {
   39   2              //获取电感值
   40   2              indRawData[0] = adc_once(IND_MF, ADC_10BIT);
   41   2              indRawData[1] = adc_once(IND_LL, ADC_10BIT);
   42   2              indRawData[2] = adc_once(IND_RR, ADC_10BIT);
   43   2      #ifdef IND_EXT_MidSide
                       indRawData[3] = adc_once(IND_LM, ADC_10BIT);
                       indRawData[4] = adc_once(IND_RM, ADC_10BIT);
               #endif
   47   2      #ifdef IND_EXT_MidRear
                       indRawData[5] = adc_once(IND_MR, ADC_10BIT);
               #endif
   50   2              for (j = 0; j < indNum; j++)
   51   2              {
   52   3                  //判断最大最小值
   53   3                  if (indRawData[j] > indRawDataMax[j])
   54   3                      indRawDataMax[j] = indRawData[j];
   55   3                  if (indRawData[j] < indRawDataMin[j])
   56   3                      indRawDataMin[j] = indRawData[j];
   57   3                  //进行累加
C251 COMPILER V5.60.0,  indNavi                                                            14/03/22  14:46:08  PAGE 2   

   58   3                  indFilteredData[j] += indRawData[j];
   59   3              }
   60   2          }
   61   1          //去除最大最小值以后进行均值滤波
   62   1          for (i = 0; i < indNum; i++)
   63   1          {
   64   2              indFilteredData[i] -= (indRawDataMax[i] + indRawDataMin[i]);
   65   2              indFilteredData[i] /= (indAvgFilterNum - 2);
   66   2          }
   67   1          //归一化，自动刷新上下限
   68   1          for (i = 0; i < indNum; i++)
   69   1          {
   70   2              if (indFilteredData[i] >= indMaxData[i])
   71   2              {
   72   3                  indDataArray[i] = 99;
   73   3                  indMaxData[i] = indFilteredData[i];
   74   3              }
   75   2              else if (indFilteredData[i] <= indMinData[i])
   76   2              {
   77   3                  indDataArray[i] = 0;
   78   3                  indMinData[i] = indFilteredData[i];
   79   3              }
   80   2              else
   81   2              {
   82   3                  indDataArray[i] = (uint8)((indFilteredData[i] - indMinData[i]) * 99 / (indMaxData[i] - indMin
             -Data[i]));
   83   3              }
   84   2          }
   85   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       457     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        36          2
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
